# 我为什么讨厌 React

前言
从设计角度分析 react
从 React 看前端代码范式革命

最开始并不是这样的，遥想十年前第一次见面时：  
![alt text](image.png)

那“小甜甜”是如何变成“牛夫人”的？  
两次前端革命的引领者 —— React，为何现在成了被革命的对象？

<!-- 时代变了 -->

1. 历史背景
2. 第一次革命、第二次革命
   1. 第一次，优点：jsx
   2. 第二次，优点：函数式组件、API 设计
   3. 2.5 次，svelte runnes 符文
3. 现存的问题（我不喜欢的点）
   1. 优雅背后的万恶之源：反直觉、难以预测运行机制
      1. 禁止条件分支中的 useState
      2. 一个个丑陋的补丁： useMemo useCallback
   2. 越来越多的内置 hooks
4. 出路在哪里
   1. react 遗留的问题，被抛弃的 css
      1. 关注点分离思想的继承者 —— vue
   2. 前后端统一组件，react、vue
      1. 但不是 use server
   3. svelte
   4. 理想化的范式应该什么样子？
5. 私货
   1. 关注点分离 错了吗？
      1. 没错，物极必反，复杂度增加后就不适应了
      2. 违反了亲密性原则（高内聚、低耦合）
      3. 有机会聊聊基本的、通用的、普世原则之一 —— 亲密性原则
         1. 就像隐藏在自然规则之下原始神格，是 React 两次革命背后的推手

## 前端代码范式演进

**html**

**jsx: 类组件**

**jsx: 函数组件**

<!-- 放到后面 -->

**未来期望**

## 往事云烟

2013 年 React 发布时，复杂前端页面代码是分别写在 html+js+css 三个不同文件中的。  
那时很多开发者看 React 多少有点**大逆不道**，因为它违反了“关注点分离”的设计思想。

“关注点分离”思想统治前端开发很多年，根源在于浏览器使用三个不同类型的标签来描述 UI 的结构（div）、交互（script）、样式（style），再由 jQuery 加以巩固。

<!-- （狭义的前端开发从 2009 年开始产生，Nodejs 诞生 -->

随着前端页面越来越复杂，“关注点分离”思想逐渐成为实际工作生产的阻碍。  
DOM 是一棵大而复杂的树形结构对象，jQuery 提供了非常便捷的方法，可以随意操作这棵树上的父子、兄弟节点。  
几个回合下来，很难直观理解这棵树的结构了；  
几十个回合下来，很难解释为什么某元素会在这里，或者某元素为什么不见了。

“关注点分离” + jQuery 时期，你维护一个最简单的导航列表，面对的是这样的数据结构：
![alt text](image-1.png)

jQuery 操作 DOM 确实便捷，但难以追溯的 DOM 变更行为；  
你可以想象一下，事件回调、ajax 异步回调、定时器不停地异步操作 DOM 树，代码散落在几千行的 js 文件中，对维护者来说就是噩梦。

本质原因是，js 代码可以在任何地方随意操作 DOM 上的任意节点，旧范式没有任何限制，就**相当于鼓励随意操作 DOM 的行为**。  
就像无限自由，就是鼓励混乱。

避免被杠，先说明一下  
良好的编码规范、贯彻执行的 CodeReview，即使旧范式也能控制混乱的增长速度；  
但这在多成员、快速迭代的项目中几乎是无法实现的，所以需要新范式、新思想。

_当时的“复杂”是相对更古早的静态页面，相对现在复杂程度只能算是小儿科了。_

## 革命

### 第一次

背景：前端页面越来越复杂，现有代码结构、范式阻碍了生产力发展
思想：组件化、数据驱动
武器：jsx
影响：

1. 前端项目进入编译时代
2. 组件化思想彻底普及
3. 数据驱动替代了 DOM 操作

它将页面拆分成组件，有效隔离了各个模块间的复杂度；  
将结构（div）与交互（js）代码融合在一起，由数据驱动视图；  
开发者的工作不再是命令式地虚空操作 DOM 树，而是维护组件中的状态，由状态生成的 DOM 结构在旁边的 `render` 函数中就能看到。

<!-- 彼时 React 高举“组件化”思想大旗，开启一场轰轰烈烈的革命。   -->

React 只是稍微扩展了一下 js 语法（jsx 两句话概括：js 中允许写标签，标签中花括号内是 js 表达式）。  
用最简单的设计、极低的用户学习成本，就实现**组件化 + 数据驱动视图**，将 html 融入 js 之中，如此自然、优雅。

```jsx
<ul>
  {list.map((it) => (
    <li>{it}</li>
  ))}
</ul>
```

### 2013 ～ 新问题

React 创造了一个繁荣的社区，涌现无数基于 React 的 UI 组件库、可复用场景的页面级组件、基于组件的低代码系统……

类组件代码快速膨胀，一个状态值离需要渲染它的节点、变更它方法往往相隔几十行甚至上百行代码，形成新的“关注点分离”模式

1. `this.state`：巨大的组件状态对象
2. `this.render`：组件的 DOM 结构
3. `其他类方法`：响应用户交互，变更状态，刷新 DOM

```jsx
class Component {
  constructor() {
    this.state = {
      // 其他状态...
      inputText: '',
      // 其他状态...
    };
  }

  // 其他方法 ...

  onInput = (evt) => {
    this.setState({
      inputText: evt.target.value,
    });
  };

  // 其他方法 ...

  render() {
    return (
      <div>
        <input value={this.state.inputText} onInput={this.onInput}></input>
        {/* ... */}
      </div>
    );
  }
}
```

虽说良好的编码规范、贯彻执行的 CodeReview，即使旧范式也能控制混乱的增长速度；  
但创建类组件的成本（模板代码较多），加上类（class）本身特性鼓励副作用方法；  
所以说**类组件范式，鼓励巨型组件**，即将新增代码加入已有组件使之巨型化，而不是拆分组件。

### 第二次

**背景：** 前端项目复杂度进一步增加，类组件代码快速膨胀
思想：函数式组件
武器：hooks API
影响：hooks 维持状态的函数式组件范式成为新时代

解释说明：
React 借由领导者地位，迅速将 hooks API 扩散至每一个角落。

<!-- ----------------------- -->

<!-- 它的缺陷可以从 React 早期的广告标签中反向体现出来 -->

初见 React 非常惊艳（如上图），  
React 带来了组件化思想

数据驱动视图、虚拟 DOM

我是在 2015 年开始接触 React，

最基本的思想都不是原创，React 的牛逼之处在于，一点点小发明 让他们迅速普及
组件化、数据驱动视图
函数组件、函数中管理状态

1. 复杂度只会增长，不会降低
2. 工具只能采用更优的方法管理复杂度
